#ifndef SPARSE_VECTOR_HPP
#define SPARSE_VECTOR_HPP

#include "Vector.hpp"
#include "Matrix.hpp"

#include <vector>
#include <cassert>

template<class T>
class SparseVector{
	
	private:
		//Add your data members here!
		std::vector<T> mDataVals;
		std::vector<T> mDataIndices;
		int mDim;
		int mDimNonZeroData = 0;
		T mZeroValue = 0;

	public:
		//creates an empty vector of dimensionality 0.
		SparseVector(){
			mDataVals = std::vector<T>();
			mDataIndices = std::vector<T>();
		};
		// Creates a vector of dimensionality dim. It starts with 0 nonzero elements
		// which need to be set using setValue
		SparseVector(unsigned int dim){
			mDataVals = std::vector<T>();
			mDataIndices = std::vector<T>();
			mDim = dim;
		};
		
		// assignment operators and copy constructor should be automatically
		// generated by the compiler when using a std::vector for internal storing.
		// However, test that assignment works!

		//sets the value v_i of the vector. if it does not exist it is added 
		void setValue(unsigned int index, T value){
			assert(index<mDim);
			std::cout << "mDimNonZeroData:" << mDimNonZeroData << std::endl;
			
			for (int i = 0; i < mDimNonZeroData; i++)
			{
				if(index == mDataIndices[i]){
					mDataVals[i] = value;
					//std::cout << "1 Leaving setValue() " << std::endl;
					break;
				}
				if( index < mDataIndices[i] ){
					auto itInd = mDataIndices.begin();
					mDataIndices.insert(itInd+i, index);
				
					auto itVal = mDataVals.begin();
					mDataVals.insert(itVal+i, value);
					mDimNonZeroData++;
					//std::cout << "2 Leaving setValue() " << std::endl;
					break;
				}

				if ( i == mDimNonZeroData-1 )
				{
					mDataVals.push_back(value);
					mDataIndices.push_back(index);
					mDimNonZeroData++;
				}
				
			}
			
			if (mDimNonZeroData == 0)
			{
				mDataVals.push_back(value);
				mDataIndices.push_back(index);
				//std::cout << "mDataVals[0]: " << mDataVals[0] << std::endl;
			}
			
			mDimNonZeroData++;
			//std::cout << "3 Leaving setValue() " << std::endl;

			//std::cout << "mDimNonZeroData (get): " << mDimNonZeroData << std::endl;
		};
			
		//returns the value v_i of the vector. Returns 0 if the value is not stored
		T getValue(unsigned int index)const{
			// std::cout << "in getValue()" << std::endl;
			// std::cout << "mDimNonZeroData " << mDimNonZeroData << std::endl;

			for (int i = 0; i < mDimNonZeroData; i++)
			{
				//std::cout << "get " << i << std::endl;
				//std::cout << "index " << index << std::endl;
				//std::cout << "mDataIndices[i] " << mDataIndices[i] << std::endl;
				if(index == mDataIndices[i]){
					return mDataVals[i];
				}
				
			}
			// std::cout << "LEaving getvalue()" << std::endl;
			return mZeroValue;
			
		};

		//returns the dimensionality of the vector
		unsigned int size()const{
			return mDim;
		};

		// returns the number stored elements
		unsigned int nonZeroes()const{
			return mDimNonZeroData;
		};

		//returns the index of the ith stored nonzero entry (in increasing order)
		unsigned int indexNonZero(unsigned int i)const{
			assert(i>mDimNonZeroData);
			return mDataIndices[i];
		};

		//returns the value of the ith stored nonzero entry (in increasing order)
		T valueNonZero(unsigned int i)const{
			assert(i>mDimNonZeroData);
			return mDataVals[i];
		
		};

		//adds x too the current vector
		SparseVector<T>& operator+= (SparseVector<T> const& x){
			T mVal;
			SparseVector sparseV(mDim);
			sparseV.mDataIndices = mDataIndices;
			sparseV.mDataVals = mDataVals;
			sparseV.mDimNonZeroData =  mDimNonZeroData;

			int j = 0;
			for (auto i: x.mDataIndices)
			{
				mVal = getValue(i);
				
				std::cout << "mVal: " << mVal << " | mZeroValue: " <<  mZeroValue << std::endl;
				std::cout << "mVal == mZeroValue" << (mVal == mZeroValue) << std::endl;
				
				if(mVal == mZeroValue){ // *** is 0.0 the right one, what if it is an integer???
				
					std::cout << "x.mDataVals[i]: " << x.mDataVals[j] << std::endl;
				
					sparseV.setValue(i, x.mDataVals[j]);
				
					std::cout << "sparseV.getValue(" << i << ") " << sparseV.getValue(i) <<std::endl;

				}else{
					sparseV.setValue(i, x.mDataVals[i] + mVal);
				}
				j++;
			}
			
			sparseV.mZeroValue = mZeroValue + x.mZeroValue;
/*
			for (int i = 0; i < sparseV.size(); i++)
			{
				std::cout << "sparseV[" << i <<"]: " << sparseV.getValue(i) << std::endl;
			}
*/		
			return sparseV; // ***** WTF ******
		}

		//subtracts x from the current vector
		SparseVector<T>& operator-= (SparseVector<T> const& x){

			T mVal;
			SparseVector sparseV(mDim);
			sparseV.mDataIndices = mDataIndices;
			sparseV.mDataVals = mDataVals;
			sparseV.mDimNonZeroData = mDimNonZeroData;

			int j = 0;
			for (auto i: x.mDataIndices)
			{
				mVal = getValue(i);
				
				std::cout << "mVal: " << mVal << " | mZeroValue: " <<  mZeroValue << std::endl;
				std::cout << "mVal == mZeroValue" << (mVal == mZeroValue) << std::endl;
				
				if(mVal == mZeroValue){ // *** is 0.0 the right one, what if it is an integer???
				
					std::cout << "x.mDataVals[i]: " << x.mDataVals[j] << std::endl;
				
					sparseV.setValue(i, -x.mDataVals[j]);
				
					std::cout << "sparseV.getValue(" << i << ") " << sparseV.getValue(i) <<std::endl;

				}else{
					sparseV.setValue(i, mVal - x.mDataVals[i]);
				}
				j++;
			}
			
			sparseV.mZeroValue = mZeroValue - x.mZeroValue;
/*
			for (int i = 0; i < sparseV.size(); i++)
			{
				std::cout << "sparseV[" << i <<"]: " << sparseV.getValue(i) << std::endl;
			}
*/		
			return sparseV; // ***** WTF ******
		}
};


// computes z= x+y, equivalent to z=x, z+=y
template<class T>
SparseVector<T> operator+(SparseVector<T> const& x, SparseVector<T> const& y){
	assert(x.size()==y.size());
	
	T mVal;
	SparseVector sparseV(mDim);
	sparseV.mDataIndices = mDataIndices;
	sparseV.mDataVals = mDataVals;
	sparseV.mDimNonZeroData = mDimNonZeroData;

	int j = 0;
	for (auto i: x.mDataIndices)
	{
		if(y.getValue(i) != y.mZeroValue){ // *** is 0.0 the right one, what if it is an integer???
			sparseV.setValue(i, y.mDataVals[i] + x.mDataVals[j]);
		}else{			
			sparseV.setValue(i, x.mDataVals[j]);
		}
		j++;
	}

	for (auto i: y.mDataIndices)
	{
		if(x.getValue(i) != x.mZeroValue){ // *** is 0.0 the right one, what if it is an integer???
			continue;
		}else{			
			sparseV.setValue(i, y.mDataVals[j]);
		}
		j++;
	}
	
	sparseV.mZeroValue = mZeroValue + x.mZeroValue;
/*
	for (int i = 0; i < sparseV.size(); i++)
	{
		std::cout << "sparseV[" << i <<"]: " << sparseV.getValue(i) << std::endl;
	}
*/		
	return sparseV; // ***** WTF ******
};

// computes z= x-y, equivalent to z=x, z-=y
template<class T>
SparseVector<T> operator-(SparseVector<T> const& x, SparseVector<T> const& y);


// computes the matrix-vector product of a dense matrix and sparse vector z=Ax.
// The result is a dense vector.
template<class T>
Vector<T> operator* (Matrix<T> const& A, SparseVector<T> const& x);

// computes the matrix-vector product of a dense matrix and sparse vector z=x^TA.
// The result is a dense vector.
template<class T>
Vector<T> operator* (SparseVector<T> const& x, Matrix<T> const& A);


#endif