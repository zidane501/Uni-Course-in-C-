#ifndef SPARSE_VECTOR_HPP
#define SPARSE_VECTOR_HPP

#include "Vector.hpp"
#include "Matrix.hpp"

#include <vector>
#include <cassert>

template<class T>
class SparseVector{
	
	private:
		//Add your data members here!
		std::vector<T> mDataVals;
		std::vector<T> mDataIndices;
		int mDim;
		int mDimNonZeroData = 0;
		T mZeroValue = 0;

	public:

		// Overridden copy constructor
		// Allocates memory for new vector, and copies
		// entries of other vector into it
		SparseVector(const SparseVector<T>& otherVector){
			std::cout << "Enter "<< " *Vector(const Vector<T>& otherVector)* - copyconstructor" << std::endl;

			mDim = otherVector.size();
			mDimNonZeroData = otherVector.nonZeroes(); 
			for (int i=0; i<otherVector.nonZeroes(); i++){
				mDataIndices.push_back(otherVector.indexNonZero(i));
				mDataVals.push_back(otherVector.valueNonZero(i));
			}

		}
		//creates an empty vector of dimensionality 0.
		SparseVector(){
			mDataVals = std::vector<T>();
			mDataIndices = std::vector<T>();
		};
		// Creates a vector of dimensionality dim. It starts with 0 nonzero elements
		// which need to be set using setValue
		SparseVector(unsigned int dim){
			mDataVals = std::vector<T>();
			mDataIndices = std::vector<T>();
			mDim = dim;
		};
		
		// assignment operators and copy constructor should be automatically
		// generated by the compiler when using a std::vector for internal storing.
		// However, test that assignment works!

		//sets the value v_i of the vector. if it does not exist it is added 
		void setValue(unsigned int index, T value){
			assert(index<mDim);
			
			// Check for value
			int localIndex;
		
			auto result1 = std::find(std::begin(mDataIndices), std::end(mDataIndices), index);

			std::cout << "result1" << result1 << std::endl;
			
			if (result1 != std::end(mDataIndices)) {
				std::cout << "v contains: " << '\n';
				localIndex = std::distance(std::begin(mDataIndices), result1);
				mDataVals[localIndex] = value;
			} else {
				std::cout << "v does not contain: " << n1 << '\n';
				mDataIndices.insert(mDataIndices.end());
				mDataVals.insert(mDataVals.end())
			}
		
		};
		
		//returns the value v_i of the vector. Returns 0 if the value is not stored
		T getValue(unsigned int index)const{
			assert(index<mDim);
			
			// Check for value
			int localIndex;
		
			auto result1 = std::find(std::begin(mDataIndices), std::end(mDataIndices), index);

			std::cout << "result1" << result1 << std::endl;
			
			if (result1 != std::end(mDataIndices)) {
				
				std::cout << "v contains: " << n1 << '\n';
				localIndex = std::distance(std::begin(mDataIndices), result1)
				return mDataVals[localIndex];

			} else {
				return mZeroValue;				
			}

			
		};

		//returns the dimensionality of the vector
		unsigned int size()const{
			return mDim;
		};

		T getZeroValue()const{
			return mZeroValue;
		}
		// returns the number stored elements
		unsigned int nonZeroes()const{
			return mDimNonZeroData;
		};

		//returns the index of the ith stored nonzero entry (in increasing order)
		unsigned int indexNonZero(unsigned int i)const{
			assert(i>mDimNonZeroData);
			return mDataIndices[i];
		};

		//returns the value of the ith stored nonzero entry (in increasing order)
		T valueNonZero(unsigned int i)const{
			assert(i>mDimNonZeroData);
			return mDataVals[i];
		
		};

		std::vector<T> getDataIndices()const{
			return mDataIndices;
		}

		//adds x too the current vector
		SparseVector<T>& operator+= (SparseVector<T> const& x){
			T mVal;

			int j = 0;
			for (auto i: x.mDataIndices)
			{
				mVal = getValue(i);
				
				if(mVal == mZeroValue){ 
					setValue(i, x.mDataVals[j]);
				}else{
					setValue(i, mVal + x.mDataVals[j]);
				}
				j++;
			}
			
			mZeroValue = mZeroValue + x.mZeroValue;
		
			return *this;
		
		}

		//subtracts x from the current vector
		SparseVector<T>& operator-= (SparseVector<T> const& x){

			T mVal;

			int j = 0;
			for (auto i: x.mDataIndices)
			{
				mVal = getValue(i);
				
				if(mVal == mZeroValue){ 
					setValue(i, -x.mDataVals[j]);
				}else{
					setValue(i, mVal - x.mDataVals[j]);
				}
				j++;
			}
			
			mZeroValue = mZeroValue - x.mZeroValue;

			return *this; 
		}
};


// computes z= x+y, equivalent to z=x, z+=y
template<class T>
SparseVector<T> operator+(SparseVector<T> const& x, SparseVector<T> const& y){

	T mVal;

	SparseVector<T> newVector(x.size());

	int j = 0;

	for (auto i: x.getDataIndices())
	{
		mVal = y.getValue(i);
		
		if(mVal == y.getZeroValue()){ 
			newVector.setValue(i, x.getValue(i));
		}else{
			newVector.setValue(i, mVal + x.getValue(i));
		}
		j++;
	}

	j = 0;
	for (auto i: y.getDataIndices())
	{
		mVal = x.getValue(i);
		
		if(mVal == x.getZeroValue()){ 
			newVector.setValue(i, y.getValue(i) );
		}else{
			continue;
		}
		j++;
	}

	return newVector; 

};

// computes z= x-y, equivalent to z=x, z-=y
template<class T>
SparseVector<T> operator-(SparseVector<T> const& x, SparseVector<T> const& y){
	T mVal;

	SparseVector<T> newVector(x.size());

	int j = 0;

	for (auto i: x.getDataIndices())
	{
		mVal = y.getValue(i);
		
		if(mVal == y.getZeroValue()){ 
			newVector.setValue(i, -x.getValue(i));
		}else{
			newVector.setValue(i, mVal - x.getValue(i));
		}
		j++;
	}

	j = 0;
	for (auto i: y.getDataIndices())
	{
		mVal = x.getValue(i);
		
		if(mVal == x.getZeroValue()){ 
			newVector.setValue(i, -y.getValue(i) );
		}else{
			continue;
		}
		j++;
	}

	return newVector; 
};


// computes the matrix-vector product of a dense matrix and sparse vector z=Ax.
// The result is a dense vector.
template<class T>
Vector<T> operator* (Matrix<T> const& A, SparseVector<T> const& x){
	Vector<T> newVector(A.GetNumberOfRows());

	for (int row = 0; row < A.GetNumberOfRows(); row++)
	{	
		T row_sum = 0;
		for (int i = 0; i < x.nonZeroes(); i++)
		{
			T index = x.getDataIndices()[i];
			row_sum += A(row, index)*x.getValue(index);
		}
		newVector[row] = row_sum;
	}
	
	return newVector;
};

// computes the matrix-vector product of a dense matrix and sparse vector z=x^TA.
// The result is a dense vector.
template<class T>
Vector<T> operator* (SparseVector<T> const& x, Matrix<T> const& A){
	Vector<T> newVector(A.GetNumberOfRows());

	for (int col = 0; col < A.GetNumberOfColumns(); col++)
	{	
		T col_sum = 0;
		for (int i = 0; i < x.nonZeroes(); i++)
		{
			T index = x.getDataIndices()[i];
			col_sum += A(index, col)*x.getValue(index);
		}
		newVector[col] = col_sum;
	}
	
	return newVector;
};


#endif