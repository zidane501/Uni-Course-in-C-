#ifndef SPARSE_VECTOR_HPP
#define SPARSE_VECTOR_HPP

#include "Vector.hpp"
#include "Matrix.hpp"

#include <vector>
#include <cassert>
#include <algorithm>
#include <iterator>

template<class T>
class SparseVector{
	
	private:
		//Add your data members here!
		std::vector<T> mDataVals;
		std::vector<int> mDataIndices;
		int mDim;
		int mDimNonZeroData = 0;
		T mZeroValue = 0;

	public:

		// Overridden copy constructor
		// Allocates memory for new vector, and copies
		// entries of other vector into it
		SparseVector(const SparseVector<T>& otherVector){
			std::cout << "Enter "<< " *Vector(const Vector<T>& otherVector)* - copyconstructor" << std::endl;

			this->mDataIndices.clear();
			this->mDataVals.clear();

			this->mDim = otherVector.size();
			this->mDimNonZeroData = otherVector.nonZeroes(); 
			
			for (int i=0; i<otherVector.nonZeroes(); i++){
				this->mDataIndices.push_back(otherVector.indexNonZero(i));
				this->mDataVals.push_back(otherVector.valueNonZero(i));
			}

		}
		//creates an empty vector of dimensionality 0.
		SparseVector(){
			mDim = 0;
		};
		// Creates a vector of dimensionality dim. It starts with 0 nonzero elements
		// which need to be set using setValue
		SparseVector(unsigned int dim){
			mDim = dim;
		};
		
		// assignment operators and copy constructor should be automatically
		// generated by the compiler when using a std::vector for internal storing.
		// However, test that assignment works!

		//sets the value v_i of the vector. if it does not exist it is added 
		void setValue(unsigned int index, T value){
			assert(index<mDim);
				
			// Check for value
			int localIndex;
			
			auto result1 = std::find(this->mDataIndices.begin(), this->mDataIndices.end(), index);
			//auto result1_1 = std::distance(this->mDataIndices.begin(), result1);
			
			if (result1 != std::end(mDataIndices)) {
				
				localIndex = std::distance(std::begin(mDataIndices), result1);
				this->mDataVals[localIndex] = value;
			
			} else {
				//std::cout << "v does not contain: "  << '\n';
				
				this->mDataVals.push_back(value);
				this->mDataIndices.push_back(index);
				
				this->mDimNonZeroData++;
			}
		
		};
		
		//returns the value v_i of the vector. Returns 0 if the value is not stored
		T getValue(unsigned int index)const{
			assert(index<mDim);
			
			// Check for value
			int localIndex;
		
			auto result1 = std::find(this->mDataIndices.begin(), this->mDataIndices.end(), index);

			//std::cout << "result1" << result1 << std::endl;
			
			if (result1 != this->mDataIndices.end()) {
				
				//std::cout << "v contains: " << '\n';
				localIndex = std::distance(this->mDataIndices.begin(), result1);
				return this->mDataVals[localIndex];

			} else {
				return this->mZeroValue;				
			}

			
		};

		//returns the dimensionality of the vector
		unsigned int size()const{
			return this->mDim;
		};

		T getZeroValue()const{
			return this->mZeroValue;
		}
		// returns the number stored elements
		unsigned int nonZeroes()const{
			return this->mDimNonZeroData;
		};

		//returns the index of the ith stored nonzero entry (in increasing order)
		unsigned int indexNonZero(unsigned int i)const{
			//assert(i>mDimNonZeroData);
			return this->mDataIndices[i];
		};

		//returns the value of the ith stored nonzero entry (in increasing order)
		T valueNonZero(unsigned int i)const{
			//assert(i>mDimNonZeroData);
			return this->mDataVals[i];
		
		};

		//adds x too the current vector
		SparseVector<T>& operator+= (SparseVector<T> const& x){
			T mVal;

			int j = 0;
			for (auto i: x.mDataIndices)
			{
				mVal = getValue(i);
				
				if(mVal == mZeroValue){ 
					setValue(i, x.mDataVals[j]);
				}else{
					setValue(i, mVal + x.mDataVals[j]);
				}
				j++;
			}
			
			this->mZeroValue = this->mZeroValue + x.mZeroValue;
		
			return *this;
		
		}

		//subtracts x from the current vector
		SparseVector<T>& operator-= (SparseVector<T> const& x){

			T mVal;

			int j = 0;
			for (auto i: x.mDataIndices)
			{
				mVal = getValue(i);
				
				if(mVal == this->mZeroValue){ 
					setValue(i, -x.mDataVals[j]);
				}else{
					setValue(i, mVal - x.mDataVals[j]);
				}
				j++;
			}
			
			this->mZeroValue = mZeroValue - x.mZeroValue;

			return *this; 
		}
};


// computes z= x+y, equivalent to z=x, z+=y
template<class T>
SparseVector<T> operator+(SparseVector<T> const& x, SparseVector<T> const& y){

	T mVal;

	SparseVector<T> newVector;

	newVector = x;
	newVector += y;

	return newVector; 

};

// computes z= x-y, equivalent to z=x, z-=y
template<class T>
SparseVector<T> operator-(SparseVector<T> const& x, SparseVector<T> const& y){
	T mVal;

	SparseVector<T> newVector = x;
	newVector -= y;

	return newVector; 
};


// computes the matrix-vector product of a dense matrix and sparse vector z=Ax.
// The result is a dense vector.
template<class T>
Vector<T> operator* (Matrix<T> const& A, SparseVector<T> const& x){
	//std::cout << "A.GetNumberOfRows()==x.size(): " << A.GetNumberOfColumns() << std::endl;
	//std::cout << "x.size(): " << x.size() << std::endl;

	assert(A.GetNumberOfColumns()==x.size());

	Vector<T> newVector(A.GetNumberOfRows());

	int index;

	for (int row = 0; row < A.GetNumberOfRows(); row++)
	{	
		T col_sum = 0;
		
		for (int i = 0; i < x.size(); i++)
		{
			
			//std::cout << "col, i" << i << std::endl;
			col_sum += A(row, i)*x.getValue(i);
		}
		newVector[row] = col_sum;
		std::cout << "newVector[row]" << newVector[row] << std::endl;
	}
	
	return newVector;
};

// computes the matrix-vector product of a dense matrix and sparse vector z=xA.
// The result is a dense vector.
template<class T>
Vector<T> operator* (SparseVector<T> const& x, Matrix<T> const& A){
	assert(A.GetNumberOfRows()==x.size());

	Vector<T> newVector(A.GetNumberOfColumns());

	std::cout << "Yo" << std::endl;
	int index;

	for (int col = 0; col < A.GetNumberOfColumns(); col++)
	{	
		T col_sum = 0;
		
		for (int i = 0; i < x.size(); i++)
		{
			std::cout << "i,col:" << i << "," << col << std::endl;

			col_sum += A(i, col)*x.getValue(i);
		}
		newVector[col] = col_sum;
		std::cout << "newVector[col]" << newVector[col] << std::endl;
	}
	
	return newVector;
};


#endif